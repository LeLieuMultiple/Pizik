import os
from gpiozero import Button
from pythonosc import osc_message_builder
from pythonosc import udp_client
from pythonosc import dispatcher
from pythonosc import osc_server
from time import sleep
import argparse
import sys
import pygame
from pygame import *
pygame.init()

# Mise en place de l'interface graphique :

LISTE_SYNTHES = ['Sine', 'Tri', 'Square']
liste_boutons = []

LARGEUR_FENETRE = 900
HAUTEUR_FENETRE = 600

DISPLAYSURF = pygame.display.set_mode( ( LARGEUR_FENETRE, HAUTEUR_FENETRE ) )
pygame.display.set_caption('Interface Clavier')

font = pygame.font.Font(None, 30)

def initialiser_boutons():
	for i in range ( len(LISTE_SYNTHES) ):
		nouveau_bouton = Bouton(LISTE_SYNTHES[i], [ 5 + i * 105, 5 ])
		liste_boutons.append(nouveau_bouton)

def dessiner_boutons():
	for i in range ( len(liste_boutons) ):
		if liste_boutons[i].statut:
			pygame.draw.rect(DISPLAYSURF, [0, 255, 0], (liste_boutons[i].position, ( 100, 25 )), 0 )
		else:
			if liste_boutons[i].souris:
				pygame.draw.rect(DISPLAYSURF, [255, 255, 0], (liste_boutons[i].position, ( 100, 25 )), 0 )
			else:
				pygame.draw.rect(DISPLAYSURF, [255, 0, 0], (liste_boutons[i].position, ( 100, 25 )), 0 )
			
		text = font.render( liste_boutons[i].texte, True, (0,0,0) )
		DISPLAYSURF.blit(text, ( 5 + i * 105, 5 ) )
		
def update():
	dessiner_boutons()
	pygame.display.update()
		
class Bouton:
	def __init__(self, texte, position):
		self.texte = texte
		self.position = position
		self.souris = False
		self.statut = False

initialiser_boutons()	
dessiner_boutons()

pygame.display.update()

while True:
	print('ok')
	mouse = pygame.mouse.get_pos()
	KEY = pygame.key.get_pressed()

	for event in pygame.event.get():

		if event.type == QUIT or KEY[pygame.K_ESCAPE]:
			pygame.quit()
			sys.exit()
		
		if event.type == MOUSEMOTION:
			for i in range ( len(liste_boutons) ):
				liste_boutons[i].souris = False
				if mouse[0] > liste_boutons[i].position[0] and mouse[0] < liste_boutons[i].position[0] + 100:
					if mouse[0] > liste_boutons[i].position[1] and mouse[1] < liste_boutons[i].position[1] + 25:
						liste_boutons[i].souris = True
			update()
						
		if event.type == MOUSEBUTTONDOWN:
			if event.button == 1:
				for i in range ( len(liste_boutons) ):
					if liste_boutons[i].souris == True:
						if liste_boutons[i].statut:
							liste_boutons[i].statut = False
						else:
							for j in range ( len(liste_boutons) ):
								liste_boutons[j].statut = False
							liste_boutons[i].statut = True
							sender.send_message('/test',0)
				update()
			
	try:
		#use try...except to handle possible errors
		#first set up and deal with input args when program starts
		parser = argparse.ArgumentParser()
		#This arg gets the server IP address to use. 127.0.0.1 or
		#The local IP address of the PI, required when using external Sonic Pi
		parser.add_argument("--ip",
		default="127.0.0.1", help="The ip to listen on")
		#This is the port on which the server listens. Usually 8000 is OK
		#but you can specify a different one
		parser.add_argument("--port",
			type=int, default=8000, help="The port to listen on")
		#This is the IP address of the machine running Sonic Pi if remote
		#or you can omit if using Sonic Pi on the local Pi.
		parser.add_argument("--sp",
			default="127.0.0.1", help="The ip Sonic Pi is on")
		args = parser.parse_args()
		if args.ip=="127.0.0.1" and args.sp !="127.0.0.1":
			#You must specify the local IP address of the Pi if trying to use
			#the program with a remote Sonic Pi aon an external computer
			raise AttributeError("--ip arg must specify actual local machine ip if using remote SP, not 127.0.0.1")
		#Provide feed back to the user on the setup being used    
		if args.sp == "127.0.0.1":
			spip=args.ip
			print("local machine used for SP",spip)  
		else:
			spip=args.sp
			print("remote_host for SP is",args.sp)
		#setup a sender udp-client to send out OSC messages to Sonic Pi
		#Sonic Pi listens on port 4559 for incoming OSC messages
		sender=udp_client.SimpleUDPClient(spip,4559) #sender set up for specified IP
		#dispatcher reacts to incoming OSC messages and then allocates
		#different handler routines to deal with them
		dispatcher = dispatcher.Dispatcher()
		#The following handler responds to the OSC message /testprint
		#and prints it plus any arguments (data) sent with the message
		dispatcher.map("/testprint",print)
		#Now set up and run the OSC server
		server = osc_server.ThreadingOSCUDPServer(
			(args.ip, args.port), dispatcher)
		print("Serving on {}".format(server.server_address))
		#run the server "forever" (till stopped by pressing ctrl-C)
		server.serve_forever()
	#deal with some error events
	except KeyboardInterrupt:
		print("\nServer stopped") #stop program with ctrl+C
	#Used the AttributeError to specify problems with the local ip address
	except AttributeError as err:
		print(err.args[0])
	#handle errors generated by the server
	except OSError as err:
		print("OSC server error",err.args)
	#anything else falls through
	
	pygame.time.wait(30)
